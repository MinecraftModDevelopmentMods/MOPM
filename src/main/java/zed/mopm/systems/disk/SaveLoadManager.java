package zed.mopm.systems.disk;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.*;
import zed.mopm.exceptions.MalformedModJsonException;
import zed.mopm.systems.vfs.DirectoryTree;
import zed.mopm.util.JsonLiterals;
import zed.mopm.util.ModLiterals;

import java.io.*;

/**
 * <p>This class handles saving and loading files used by this program. <br>
 * <b>Those files include:</b>
 * <ul>
 *     <li>{@link SaveLoadManager#SERVER_SAVE_FILE}</li>
 *     <li>{@link SaveLoadManager#WORLD_VFS_JSON}</li>
 *     <li>{@link SaveLoadManager#SERVER_VFS_JSON}</li>
 *     <li>{@link SaveLoadManager#VFS_PATH_JSON}</li>
 * </ul>
 * See each of the above references for usage and examples.
 * </p>
 */
public final class SaveLoadManager {

	/**
	 * A reference to the home directory of Minecraft.
	 */
	private static final File MC_HOME_DIR = Minecraft.getInstance().gameDir;

	private static final File MC_SAVES_DIR = new File(MC_HOME_DIR, "saves");

	/**
	 * <p>servers.dat is generated by Minecraft. This program adds {@link JsonLiterals#PATH_TAG}
	 * to each server in servers.dat. {@link JsonLiterals#PATH_TAG} contains the
	 * location of the server in the virtual server directory menu.</p>
	 * <br>
	 * <b>Example of Usage:</b> servers.dat
	 * <pre>
	 *     {@code
	 *     {
	 *         servers:[
	 *         	{
	 *         		ip:"some ip",
	 *         		name:"some name",
	 *         		vfs_path:"some directory location"
	 *         	},
	 *         	...
	 *         ]
	 *     }
	 *     }
	 * </pre>
	 * <p><i>ip</i> and <i>name</i> are maintained by Minecraft while <i>vfs_path</i>
	 * is added and maintained by this program. When More Organized Player Menus is
	 * loaded, <i>vfs_path</i> for each server is referenced and each server is put
	 * into the appropriate directory.</p>
	 */
	private static final File SERVER_SAVE_FILE = new File(MC_HOME_DIR, "servers.dat");

	/**
	 * <p>world_vfs.json is generated by More Organized Player Menus as long as
	 * world_vfs.json does not exist within the Minecraft instance folder. If the
	 * world_vfs.json file does not exist, a default configuration is loaded, and
	 * all worlds are checked and moved into the root directory.</p>
	 * <p>world_vfs.json makes use of {@link JsonLiterals#DIR_NAME} and
	 * {@link JsonLiterals#DIR_CHILDREN}. The json format contains a layout for
	 * how to construct a virtual file system. The following is an example of
	 * the json structure.</p>
	 * <br>
	 * <b>Json structure:</b>
	 * <pre>
	 *     {@code
	 *     {
	 *         "directory_label" : "root",
	 *         "children" : [
	 *         	{
	 *         	    "directory_label" : "some name",
	 *         	    "children" : [
	 *         	    	...
	 *         	    ]
	 *         	},
	 *         	...
	 *         ]
	 *     }
	 *     }
	 * </pre>
	 * <p>The first level of the json will always contain a directory labeled root.
	 * This acts as the source directory for every subsequent directory. The children
	 * for the a directory are then specified within the same json object as an array
	 * of json objects following the same format. The following is an example of this
	 * structure's usage.</p>
	 * <br>
	 * <b>Example of Usage:</b> world_vfs.json
	 * <pre>
	 *     {@code
	 *     {
	 *         "directory_label" : "root",
	 *         "children" : [
	 *         	{
	 *         	    "directory_label" : "world dir 1",
	 *         	    "children" : [
	 *         	    	{
	 *         	    	 	"directory_label" : "child of world dir 1",
	 *         	    	 	"children" : []
	 *         	    	}
	 *         	    ]
	 *         	},
	 *         	{
	 *         	    "directory_label" : "world dir 2",
	 *         	    "children" : []
	 *         	}
	 *         ]
	 *     }
	 *     }
	 * </pre>
	 * <p>The above is maintained by More Organized Player Menus and is constructed
	 * based on how the user organizes their directory system. The above is instructions
	 * instructing More Organized Player Menus on how to construct a tree upon loading
	 * of More Organized Player Menus:</p>
	 * <pre>
	 *     {@code
	 *     root:
	 *     	world dir 1:
	 *     		child of world dir 1:
	 *     	world dir 2:
	 *     }
	 * </pre>
	 * <p>The root directory has two children while <i>world dir 1</i> has one child.</p>
	 */
	private static final File WORLD_VFS_JSON = new File(MC_HOME_DIR, "world_vfs.json");

	private static final File WORLD_VFS_OLD = new File(MC_HOME_DIR, "world_vfs_old.json");

	/**
	 * <p>server_vfs.json is generated by More Organized Player Menus as long as
	 * server_vfs.json does not exist within the Minecraft instance folder. If the
	 * server_vfs.json file does not exist, a default configuration is loaded, and
	 * all servers are checked and moved into the root directory.</p>
	 * <p>server_vfs.json makes use of {@link JsonLiterals#DIR_NAME} and
	 * {@link JsonLiterals#DIR_CHILDREN}. The json format contains a layout for
	 * how to construct a virtual file system. The following is an example of
	 * the json structure.</p>
	 * <br>
	 * <b>Json structure:</b>
	 * <pre>
	 *     {@code
	 *     {
	 *         "directory_label" : "root",
	 *         "children" : [
	 *         	{
	 *         	    "directory_label" : "some name",
	 *         	    "children" : [
	 *         	    	...
	 *         	    ]
	 *         	},
	 *         	...
	 *         ]
	 *     }
	 *     }
	 * </pre>
	 * <p>The first level of the json will always contain a directory labeled root.
	 * This acts as the source directory for every subsequent directory. The children
	 * for the a directory are then specified within the same json object as an array
	 * of json objects following the same format. The following is an example of this
	 * structure's usage.</p>
	 * <br>
	 * <b>Example of Usage:</b> server_vfs.json
	 * <pre>
	 *     {@code
	 *     {
	 *         "directory_label" : "root",
	 *         "children" : [
	 *         	{
	 *         	    "directory_label" : "server dir 1",
	 *         	    "children" : [
	 *         	    	{
	 *         	    	 	"directory_label" : "child of server dir 1",
	 *         	    	 	"children" : []
	 *         	    	}
	 *         	    ]
	 *         	},
	 *         	{
	 *         	    "directory_label" : "server dir 2",
	 *         	    "children" : []
	 *         	}
	 *         ]
	 *     }
	 *     }
	 * </pre>
	 * <p>The above is maintained by More Organized Player Menus and is constructed
	 * based on how the user organizes their directory system. The above is instructions
	 * instructing More Organized Player Menus on how to construct a tree upon loading
	 * of More Organized Player Menus:</p>
	 * <pre>
	 *     {@code
	 *     root:
	 *     	server dir 1:
	 *     		child of server dir 1:
	 *     	server dir 2:
	 *     }
	 * </pre>
	 * <p>The root directory has two children while <i>server dir 1</i> has one child.</p>
	 */
	private static final File SERVER_VFS_JSON = new File(MC_HOME_DIR, "server_vfs.json");

	private static final File SERVER_VFS_OLD = new File(MC_HOME_DIR, "server_Vfs_old.json");

	/**
	 * <p>vfs_path.json is generated by More Organized Player Menus for each
	 * world save. vfs_path.json uses {@link JsonLiterals#PATH_TAG} indicating where a world save
	 * belongs in the virtual file system.</p>
	 * <br>
	 * <b>Example of Usage: </b> vfs_path.json in some world save directory.
	 * <pre>
	 *     {@code
	 *     {
	 *         "vfs_path" : "some vfs path"
	 *     }
	 *     }
	 * </pre>
	 * <p>Generally, since there may be more than one vfs_path.json files, this
	 * field is a String referenced to create new files.</p>
	 */
	private static final String VFS_PATH_JSON = "vfs_path.json";

	private static final String VFS_PATH_OLD = "vfs_path_old.json";

	private static final SaveLoadManager instance = new SaveLoadManager();

	private DirectoryTree worldVFS, serverVFS;

	private boolean hasModLoaded = false;

	private SaveLoadManager() {}

	public static SaveLoadManager get() {
		return instance;
	}

	/**
	 *
	 * @throws IOException
	 */
	public void loadMOPM() throws IOException {
		if (!hasModLoaded) {
			hasModLoaded = true;

			loadWorldPaths(WORLD_VFS_JSON.createNewFile());
			try {
				worldVFS = loadVfs(WORLD_VFS_JSON, new DirectoryTree());
			} catch (final MalformedModJsonException e) {
				WORLD_VFS_OLD.createNewFile();
				writeJson(readJson(WORLD_VFS_JSON).getAsString(), WORLD_VFS_OLD);
				loadWorldPaths(true);
				e.printStackTrace();
			}

			loadServerPaths(SERVER_VFS_JSON.createNewFile());
			try {
				serverVFS = loadVfs(SERVER_VFS_JSON, new DirectoryTree());
			}
			catch (final MalformedModJsonException e) {
				SERVER_VFS_OLD.createNewFile();
				writeJson(readJson(SERVER_VFS_JSON).getAsString(), SERVER_VFS_OLD);
				loadServerPaths(true);
				e.printStackTrace();
			}
		}
	}

	/**
	 *
	 * @param vfsFile
	 * @param vfs
	 * @return
	 * @throws IOException
	 * @throws MalformedModJsonException
	 */
	private DirectoryTree loadVfs(final File vfsFile, final DirectoryTree vfs)
		throws IOException, MalformedModJsonException {
		final JsonObject vfsJson = readJson(vfsFile);
		try {
			final boolean rootExists =
				getDirectoryName(vfsJson).equals(ModLiterals.ROOT_NAME);
			if (rootExists) {
				loadVfs(getDirectoryChildren(vfsJson), vfs);
			}
			return vfs;
		}
		catch (final NullPointerException e) {
			final StringBuilder err = new StringBuilder();
			err.append("A json tag in ")
				.append(vfsFile.getName())
				.append("is corrupt or missing!")
				.append("A backup has been made and replaced with a new file.");
			throw new MalformedModJsonException(err.toString(), e);
		}
	}

	/**
	 *
	 * @param children
	 * @param vfs
	 */
	private void loadVfs(final JsonArray children, final DirectoryTree vfs) {
		for (final JsonElement element : children) {
			final JsonObject child = element.getAsJsonObject();
			final String directoryName = getDirectoryName(child);
			vfs.createAndStepInto(directoryName);
			loadVfs(getDirectoryChildren(child), vfs);
			vfs.stepBack();
		}
	}

	private void loadWorldPaths(final boolean doDefaultLoad)
		throws IOException {
		for (final File worldSave : MC_SAVES_DIR.listFiles()) {
			ensureWorldPath(worldSave, doDefaultLoad);
		}
		if (doDefaultLoad) {
			writeJson(JsonLiterals.DEFAULT_VFS_STRUCT, WORLD_VFS_JSON);
		}
	}

	private void loadServerPaths(final boolean doDefaultLoad)
		throws IOException {
		final CompoundNBT nbt = CompressedStreamTools.read(SERVER_SAVE_FILE);
		if (nbt != null) {
			final ListNBT servers = nbt.getList(
				JsonLiterals.SERVERS_TAG,
				10
			);
			for (final INBT n : servers) {
				ensureServerPath((CompoundNBT) n, doDefaultLoad);
			}
		}

		if (doDefaultLoad) {
			writeJson(JsonLiterals.DEFAULT_VFS_STRUCT, SERVER_VFS_JSON);
		}
	}

	/**
	 *
	 * @param worldSave
	 * @param reset
	 * @return
	 * @throws IOException
	 */
	private boolean ensureWorldPath(final File worldSave, final boolean reset)
		throws IOException {
		final File newVfsPath = new File(worldSave, VFS_PATH_JSON);
		final boolean hasJson = newVfsPath.createNewFile();

		if (reset || !hasJson) {
			writeJson(
				JsonLiterals.DEFAULT_VFS_PATH_JSON,
				newVfsPath
			);
		}
		// Todo: Insert path into a payload.

		return hasJson;
	}

	private boolean ensureServerPath(final CompoundNBT serverNbt, final boolean reset) {
		final boolean hasPath = serverNbt.contains(JsonLiterals.PATH_TAG);

		if (reset || !hasPath) {
			serverNbt.putString(JsonLiterals.PATH_TAG, ModLiterals.ROOT_UNAME);
		}

		// Todo: Insert path, ip, and name into a payload.

		return hasPath;
	}

	/**
	 *
	 * @param json
	 * @return
	 */
	private String getDirectoryName(final JsonObject json) {
		return json.get(JsonLiterals.DIR_NAME).getAsString();
	}

	/**
	 *
	 * @param json
	 * @return
	 */
	private JsonArray getDirectoryChildren(final JsonObject json) {
		return json.getAsJsonArray(JsonLiterals.DIR_CHILDREN);
	}

	/**
	 *
	 * @param jsonFile
	 * @return
	 * @throws IOException
	 */
	private JsonObject readJson(final File jsonFile) throws IOException {
		isModJsonFile(jsonFile);
		try (final BufferedReader in = new BufferedReader(new FileReader(jsonFile))) {
			return new JsonParser().parse(in).getAsJsonObject();
		}
	}

	/**
	 *
	 * @param json
	 * @param jsonFile
	 * @throws IOException
	 */
	private void writeJson(final String json, final File jsonFile)
		throws IOException {
		isModJsonFile(jsonFile);
		try (final FileOutputStream out = new FileOutputStream(jsonFile)) {
			out.write(
				JsonLiterals.formatStringJson(json)
					.getBytes(ModLiterals.MOD_CHARSET)
			);
		}
	}

	/**
	 *
	 * @param file
	 * @throws IOException
	 */
	private void isModJsonFile(final File file) throws IOException {
		final boolean doThrow = !file.equals(WORLD_VFS_JSON)
			&& !file.equals(SERVER_VFS_JSON)
			&& !file.getName().equals(VFS_PATH_JSON);
		if (doThrow) {
			final StringBuilder errorMsg = new StringBuilder()
				.append(file.getName())
				.append(" : Is not a file used by ")
				.append("More Organized Player Menus!");
			throw new IOException(errorMsg.toString());
		}
	}
}
